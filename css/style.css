:root {
  --primary: #ffffff;
  /* White as primary accent in amoled */
  --primary-hover: #e2e2e2;
  --bg-main: #000000;
  /* Amoled Black */
  --bg-card: #000000;
  /* Amoled Black */
  --bg-input: #121212;
  /* Slightly lighter for input distinction */
  --text-primary: #ffffff;
  --text-secondary: #a3a3a3;
  --success: #ffffff;
  /* White for success (minimalist) or keep green? User said Black & White. Let's stick to monochrome/minimalist or classic green for functional feedback? "Base warnanya ganti jadi hitam amoled dan putih". I will keep functional colors but make the base b/w. Let's make success white checkmark on black box or similar. Let's stick to white for cleaner b/w look or simple high contrast. */
  --success: #ffffff;
  --danger: #ffffff;
  /* Minimalist error too? Or standard red? Usually Functional colors are kept. But "Black and White" might imply monochrome. I'll use white for icons usually. Let's keep danger red for critical actions but maybe muted. Actually, let's try strict B/W for base elements. */
  --border-radius: 0px;
  /* Amoled often looks good with sharp or slightly rounded. Let's keep 12px or reducing it? User didn't specify radius. I'll stick to colors. */
  --border-radius: 12px;
  --transition: all 0.3s ease;
  --shadow: none;
  /* Amoled usually flat or border based */
  --border-dim: #333333;
  /* Dim border for separation */
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter', sans-serif;
  background-color: var(--bg-main);
  color: var(--text-primary);
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  padding: 20px;
}

.app-container {
  width: 100%;
  max-width: 500px;
  background-color: var(--bg-card);
  border-radius: var(--border-radius);
  /* Remove shadow, add border for visibility on black */
  border: 1px solid var(--border-dim);
  padding: 2rem;
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

/* Header */
.header {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.header-top {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.app-icon {
  font-size: 1.5rem;
}

.app-title {
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--text-primary);
  /* Solid White */
}

.current-date {
  color: var(--text-secondary);
  font-size: 0.9rem;
}

/* Input Bar */
.input-bar {
  display: flex;
  gap: 0.75rem;
}

#todoInput {
  flex: 1;
  background-color: var(--bg-input);
  border: 1px solid transparent;
  padding: 0.75rem 1rem;
  border-radius: var(--border-radius);
  color: var(--text-primary);
  font-family: inherit;
  font-size: 1rem;
  transition: var(--transition);
  outline: none;
}

#todoInput:focus {
  border-color: var(--text-secondary);
  box-shadow: none;
}

.add-btn {
  background-color: var(--text-primary);
  /* White button */
  border: 1px solid var(--text-primary);
  border-radius: var(--border-radius);
  color: var(--bg-main);
  /* Black text/icon */
  width: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: var(--transition);
}

.add-btn:hover {
  background-color: transparent;
  color: var(--text-primary);
  transform: translateY(-2px);
}

.add-btn:active {
  transform: translateY(0);
}

/* Task List */
.task-list {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  min-height: 200px;
  max-height: 50vh;
  overflow-y: auto;
  padding-right: 5px;
  /* space for scrollbar */
}

/* Scrollbar styling */
.task-list::-webkit-scrollbar {
  width: 6px;
}

.task-list::-webkit-scrollbar-track {
  background: transparent;
}

.task-list::-webkit-scrollbar-thumb {
  background-color: #334155;
  border-radius: 20px;
}

.task-item {
  background-color: transparent;
  padding: 0.75rem 1rem;
  border-radius: 8px;
  display: flex;
  align-items: center;
  gap: 1rem;
  transition: var(--transition);
  animation: fadeIn 0.3s ease;
  border: 1px solid var(--border-dim);
}

.task-item:hover {
  background-color: #111;
  /* Very subtle grey on hover */
  border-color: var(--text-secondary);
  transform: none;
  /* Remove movement for cleaner feel? Or keep? Let's keep movement minimal or remove. User said Amoled, usually sleek. Let's keep movement but remove color shift mostly. */
}

.task-checkbox {
  appearance: none;
  width: 20px;
  height: 20px;
  border: 2px solid var(--text-secondary);
  border-radius: 6px;
  cursor: pointer;
  position: relative;
  transition: var(--transition);
  flex-shrink: 0;
}

.task-checkbox:checked {
  background-color: var(--text-primary);
  border-color: var(--text-primary);
}

.task-checkbox:checked::after {
  content: 'âœ“';
  color: var(--bg-main);
  /* Black checkmark on white bg */
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 12px;
  font-weight: bold;
}

.task-content {
  flex: 1;
  font-size: 1rem;
  word-break: break-all;
  transition: var(--transition);
}

.task-item.completed .task-content {
  text-decoration: line-through;
  color: var(--text-secondary);
  opacity: 0.7;
}

.edit-input {
  width: 100%;
  background: transparent;
  border: none;
  border-bottom: 2px solid var(--primary);
  color: var(--text-primary);
  font-family: inherit;
  font-size: 1rem;
  padding: 0;
  outline: none;
}

.delete-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  /* Grey by default */
  cursor: pointer;
  opacity: 0;
  transition: var(--transition);
  padding: 4px;
  border-radius: 4px;
}

.task-item:hover .delete-btn {
  opacity: 1;
}

.delete-btn:hover {
  color: var(--text-primary);
  /* White on hover */
  background-color: #222;
}

/* Empty State */
.empty-state {
  text-align: center;
  color: var(--text-secondary);
  margin-top: 2rem;
  font-style: italic;
}

/* Controls / Footer */
.controls {
  border-top: 1px solid rgba(255, 255, 255, 0.1);
  padding-top: 1rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.8rem;
  color: var(--text-secondary);
  flex-wrap: wrap;
  gap: 1rem;
}

.filters {
  display: flex;
  gap: 0.5rem;
}

.filter-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 2px 0;
  transition: var(--transition);
  font-family: inherit;
  font-weight: 500;
}

.filter-btn:hover {
  color: var(--text-primary);
}

.filter-btn.active {
  color: var(--text-primary);
  text-decoration: underline;
  text-underline-offset: 4px;
}

.clear-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  transition: var(--transition);
  font-family: inherit;
  font-size: 0.8rem;
}

.clear-btn:hover {
  color: var(--text-primary);
  text-decoration: underline;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }

  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@media (max-width: 480px) {
  .app-container {
    padding: 1.5rem;
  }

  .controls {
    flex-direction: column;
    gap: 1rem;
    align-items: center;
  }

  .filters {
    order: -1;
  }
}

/* Loading Overlay */
.loading-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid rgba(255, 255, 255, 0.3);
  border-top-color: var(--primary);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}